%!TEX root = ../../report.tex

\subsection{Griswold}
%Griswold
%Characteristics Dynamic language, Simple refactoring operations, Only One language, AST?, PDG?, Easy to create new operations?
Griswold \cite{griswold1991program} proved that meaning preserving restructuring can substantively lower the maintenance cost of a system and proved the concept by creating restructuring operations for the Scheme programming language implemented in Common Lisp.
%Scheme was chosen because of it's imperative features, simple syntax and it was available a PDG for scheme implemented in Common Lisp.


Griswold starts comparing automated restructuring with manual restructuring using an experiment. 
An initial program and a description of the four goals of the transformations to be made was presented to 6 subjects. It was also asked to each subject to make sure and demonstrate that the modifications were correct.

Even though that they tested with a really small number of subjects they managed to get several conclusions on how people manually restructure the programs.
People use the Copy/Paste and the Cut/Paste paradigm to do the transformations, they copy or cut the code and then paste it in the desired location.
The Cut/Paste paradigm is more dangerous because if the user makes any error it is be more difficult to correct the error because it is a destructive operation.

This study also managed to conclude that people make mistakes even with small and simple programs and the cost of correcting mistakes is higher than the time to do the restructuring itself.
One last conclusion was that manual restructuring is haphazard, the transformations were done in almost a random way when compared to the computer-assisted process.

It was implemented simple restructuring operations to prove the concept such as: Moving an expression, Renaming a variable, Abstracting an expression, Extracting a function, Scope-wide function replacement, Adding a reference indirection and Adding looping to list references.

In order to be able to implement correctly this operations it was used contours and a PDG (program dependence graph). 
The main representation of the program is the contours that are an abstraction of the essential semantic properties that the AST (abstract syntax tree) represents in an efficient and complete form, but the PDG does not.
The PDG is used to ensure formally that the refactoring is correct.
With contours and a way to relate components in the PDG and the AST it is possible to combine then and have a single formalism to reason effectively about flow dependencies and scope structure.

%It is possible to have this representation because it have access to everything like a compiler does, and it tries to used work done, such as using a library for the PDG. Using DrRacket the semantic part is covered by the arrows created which helps having the semantic logic between things.
