%!TEX root = ../../report.tex

%How we Refactor, and how we know it.
\subsection{Use of static refactoring tools}

Murphy et al \cite{murphy2012we} collected some data sets in order to understand how the users refactor.
The first data set that was called User data set was collected by Murphy and colleagues \cite{murphy2006java} in 2005, it has records of 41 volunteer programmers using eclipse which 95\% of them programmed in java. %Whit this we impplied that Refactoring tools are underused [10]

The Everyone data set was collected from the Eclipse Usage Collector, the data used aggregates activity from over 13000 Java developers between 04/08 to 01/09 but also include non-Java developers.

The Toolsmiths data set that consists in information about 4 developers who primarily maintain eclipse's refactoring tools. From 12/05 to 08/07 however it is not publicly available and not described in other papers, there is only a similar study by Robbes \cite{robbes2007mining} that uses data from Robbes itself and another developer. 


%Many other authors have mined software repositories automatically for refactorings (WeiBgerber and Diehl [18]) they did not know of other reseach that compares refactoring tool logs with code histories.
There were some important informations that could get from this paper.

The first one is the most common refactoring operations used by the users with some importance and they are: Rename, Extract Local Variable, Inline, extract Method and Move. The use percentages of this 5 refactoring operations is between 86.4\% and 92\% of the data sets. % 86.4 90.8 92.0
However the refactoring behavior differ among users. The most refactoring operation was the rename for all the sets, but the used percentage was drastically different between toolsmiths and other sets. Toolsmiths had 29\% while the User set and Everyone had 62\% and 75\% respectively.

Refactoring operations are frequent, using the data sets of users and toolsmiths it was possible to extract that refactoring operations are frequent. 
In the users data set, 41\% of programming sessions contained refactoring activities and the sessions that did not have refactoring activities were the sessions where less edits where made.
In toolsmith only 2 weeks of the year 2006 did not had any refactoring operation, which one of them was a winter holidays week, and it had in average, 30 refactoring operations per week. In 2007 every week had refactoring activities and the average was 47 refactoring operations a week.

Besides refactoring operations being frequent, refactoring tools are underused, to decide whether the refactoring operation was manual or tool assisted they tried to correlate refactoring activities with tool support, if the refactoring activities is correlated with tool support it is classified as a refactoring with a tool. In the end they were unable to link to 89\% of the refactoring operations to a tool supported refactoring. Even ignoring some commits that might have some problems in identifying if the refactoring is tool assisted or manual, 73\% refactorings were unable to be linked with a tool usage.
All this numbers are computed from the toolsmiths data set which is in theory is the group who knows and better uses the refactoring tools.


\subsection{Overview of static Refactoring tools}

\begin{table}[htbp]
\caption{Refactoring operations available by default}
\label{tab-Comparing-Static}
\begin{tabular}{|l|c|c|c|c|c|}
\hline
Refactoring \textbackslash IDE           & Visual Studio & Eclipse & IntelliJ & NetBeans & Jbuilder \\ \hline
Rename                    & x             & x       & x        & x        & x        \\ \hline
Move                      &               & x       & x        & x        & x        \\ \hline
Change method signature   &               & x       & x        &          &          \\ \hline
Extract method            & x             & x       & x        &          & x        \\ \hline
Extract local variable    &               & x       & x        &          & x        \\ \hline
Extract constant          &               & x       & x        &          &          \\ \hline
Inline                    &               & x       & x        & x        &          \\ \hline
Anonymous to nested       &               & x       & x        &          &          \\ \hline
Move type to new file     &               & x       & x        &          &          \\ \hline
Variable to field         &               & x       & x        &          &          \\ \hline
Extract superclass        &               & x       & x        & x        &          \\ \hline
Extract interface         & x             & x       & x        & x        &          \\ \hline
Supertype where possible  &               & x       &          & x        &          \\ \hline
Push down                 &               & x       & x        & x        &          \\ \hline
Pull up                   &               & x       & x        & x        &          \\ \hline
Extract class             &               & x       & x        &          &          \\ \hline
Introduce parameter       &               & x       & x        & x        &          \\ \hline
Introduce indirection     &               & x       &          &          &          \\ \hline
Introduce factory         &               & x       & x        & x        &          \\ \hline
Encapsulate field         & x             & x       & x        &          &          \\ \hline
Generalize declared type  &               & x       &          &          &          \\ \hline
Type Migration            &               &         & x        &          &          \\ \hline
Remove Middleman          &               &         & x        &          &          \\ \hline
Wrap Return Value         &               &         & x        &          &          \\ \hline
Safe Delete               &               &         & x        & x        &          \\ \hline
Replace Method duplicates &               &         & x        &          &          \\ \hline
Static to instance method &               &         & x        &          &          \\ \hline
Make Method Static        &               &         & x        &          &          \\ \hline
Interface where possible  &               &         & x        &          &          \\ \hline
Inheritance to delegation &               &         & x        &          &          \\ \hline
\end{tabular}
\end{table}

The ({\bf Table.~\ref{tab-Comparing-Static}}) compares this refactoring tools with each other and the Refactoring definitions can be found on ({\bf Table.~\ref{tab-Refactoring-Definitions} in Apendix ~\ref{sec:attachments}}). 
It is easy to see that IntelliJ have almost all the refactoring operations followed by Eclipse and NetBeans.
However, even having significantly less refactoring operations available by default than the other tools, the JBuilder have the essential ones and the most used ones as showed above, only Visual Studio has only 2 out of 5 more used refactoring operations available by default, but there are easily installed plug-ins that cover the more important refactoring operations. The table only has the refactoring operations by default in order to have a more fair way to compare them with each other.

It is easy to see all the effort to provide to the programmers refactoring operations to help them refactoring their projects.

 