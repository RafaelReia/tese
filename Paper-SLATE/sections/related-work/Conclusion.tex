%!TEX root = ../../report.tex


\subsection{Conclusions}
%dynamic languages are good for prototyping and are used as introductory courses.

%Few refactoring tools
%Refactoring tools for dynamic languages are still far away from the capabilities offered by the refactoring tools for static languages and in average have less refactoring operations than the refactoring tools for static languages.
%few information
%Dynamic languages have the problem of having less information available in compile time and that might explain the different capabilities of the refactoring tools for dynamic languages when compared to refactoring tools for static languages. 

%very different from each other
%The dynamic languages are also very different from each other, whereas the static languages such as Java or C\# are similar. thus the refactoring operations can have the same base/do the same checks and only adapt to the few differences between languages

%Dynamic even having way less refactoring operations when compared with static refactoring tools, they at least have the most used refactoring operation.
%The dynamic languages even having few refactoring operations, the available ones are very different from one language to another. However, the rename, which is the most used refactoring operations, is available in every dynamic refactoring tool.

%Refactoring tools for static in general have almost all of them. and that refactoring operations make sense for most of dynamic languages, if not all. => check this.


%they are made for several text editors/ IDEs whereas static refactoring tools are made for usually one specific IDE.

Dynamic languages, like Racket and Python are used in introductory courses. However even being recognized as a good languages to learn how to program there are very few tools for dynamic languages. Thus the unexperienced programmer only contacts and uses refactoring tools latter on and not when learning the basics.

Refactoring tools for dynamic languages are still far away from the capabilities offered by the refactoring tools for static languages and in average have less refactoring operations than the refactoring tools for static languages.

The biggest difficulty for the dynamic refactoring tools is the lack of information available. A dynamic language only knows type information in runtime and that make the refactoring operations more difficult when compared with the refactoring operations for static languages, where the information is always available.

In addition, dynamic languages are very different from each other whereas the static languages are more similar. 
For example, Java and C\# are very similar and even C++ that is not that similar the refactoring operations available for the language are very similar to the refactoring operations available for Java and C\#. 
This difference makes it a bit more difficult for the refactoring tools for dynamic languages when compared to the static one's. %they can't use the same refactoring bases/preconditions

%IDEs help with the refactoring operations.
Another difference between refactoring tools is the IDE support. Static refactoring tools have a IDE support for the refactoring operations, thus making it easier when compared to the usual refactoring tools for dynamic languages, that manage all the information. This disadvantage of the dynamic refactoring tools has positive point that they have more interoperability and then easier to use in different text-editors or IDEs.

%Dynamic even having way less refactoring operations when compared with static refactoring tools, they at least have the most used refactoring operation.
Even having way less refactoring operations when compared with static refactoring tools, the dynamic refactoring tools at least have the most used refactoring operation, namely the rename.




%\begin{table}[h]
%\label{tab-Comparing-All}
%\begin{tabular}{l|c|c|c|c}
%              & \multicolumn{1}{l|}{Dynamic?} & Refactoring Coverege & Interoperability & Major drawback				 		\\ \hline
%Griswold      & Yes                           & Medium               &                  &									    \\ \hline
%SmallTalk     & Yes                           & Medium               & No             	& Dependent of Unit tests \& maybe dead \\ \hline
%Javascript    & Yes                           & Very Low             &                  & Few Refactoring Operations 		    \\ \hline
%Bicycle       & Yes                           & Medium               & Yes              & Did not improve since 2004 			\\ \hline
%Rope          & Yes                           & Medium               & Yes              &                       			    \\ \hline
%Eclipse       & No                            & High                 & No               &                            			\\ \hline
%Visual Studio & No                            & Medium               & No               &                            			\\ \hline
%IntelliJ      & No                            & High                 & No               &                            			\\ \hline
%NetBeans      & No                            & Low                  & No               &                            			\\ \hline
%JBuilder      & No                            & Medium               & No               &                            			\\ \hline
%\end{tabular}
%\caption{Comparassion between Refactoring tools}
%\end{table}