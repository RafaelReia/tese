%!TEX root = ../report.tex

% 
% Introduction
% 

\section{Introduction}

%[REF]evolution survey do ments.
%\cite{drscheme} teste  \cite{drscheme_pegadogy} \cite{languages_scheme}
Over time the software artifacts tends to change, to develop gradually and expand %quando se esta a usar, depois de se usar durante algum tempo
 when being used and even during developing new requirements appear, the existing ones change, new bugs are found or some critical %SHINY! important
  new features are added.
Because of these changes the artifact starts to drift apart from it's original design in order to incorporate all those modifications.
Those modifications increases the complexity of the artifact making it less readable, more difficult to extend and harder to change, consequently making the quality lower and the maintenance costs higher. %[REF] Case study in refactoring functional programs.&& [REF] Refactoring: current research and future trends. [Ref 1 of How we refactor, and how we know it]


In order to mitigate or reverse the decreasing quality of the software, programmers tend to improve the software structure to make it more readable and easy to understand thus improving the software quality, in order words, programmers try to improve the quality of the software by refactoring the software.

Refactoring is a transformation or a set of transformations that are meant to improve the program structure without modifying the behavior. Maintaining the behavior is important because without that the modification would modify the meaning of the program and transform in a different program.
%[REF] FIND IT 
%The difference between Refactoring and restructuring is that Refactoring is used in literature to define the transformations that improve the program preserving the behavior in Object Oriented paradigm \cite{opdyke1992refactoring} \cite{fowlerrefactoring1999} whereas Restructuring is used for the rest. \cite{griswold1993automated} \cite{softrest1986} %[REF] 


%why we need refactoring tools[ref JunGL]
Because refactoring is a tedious and error prone activity, it is preferable to use a tool that provides automated support to the refactoring operations that the programmer intends to do and therefore save time and reduces the possibility of adding errors to a previous correct program.


There are refactoring tools for the different types of languages paradigms such as object oriented, functional, imperative, however the use of those tools were fully adopted by the object oriented and static programming languages with their IDE support, such as Java \footnote{https://www.oracle.com/java/index.html} with the IDEs eclipse \footnote{https://eclipse.org/}, IntelliJ \footnote{https://www.jetbrains.com/idea/} or NetBeans\footnote{https://netbeans.org/} and C\# with Visual Studio \footnote{https://www.visualstudio.com/} when %add more examples, add citations, and refs X-develop
compared to the dynamic languages there is a lack of refactoring tools and refactoring operations. 
The major difference of the refactoring tools made for the dynamic languages when compared with the ones made for static typified languages is the lack of information available about the program that is being refactored, such as the type information of variables, parameters and returns. 
Because of this the refactoring tools made for dynamic languages did not evolve like the ones made for static languages then the refactoring tools for static languages are largely used and they are considered a common tool when programming for static typified object oriented languages but they are barely used among dynamic languages.  %Must Rewrite

Despite of that, the importance of dynamic languages is growing. Mainly because they are growing very fast among unexperienced programmers, they are used a lot among the scientific community and there are new dynamic languages everyday. 
The dynamic languages are good for creating prototypes because it is easy and fast to create one. Finally they are easy to adopt and often used as a learning language, such as Scheme, Racket and Python. %% ADD REFS! use PEDRO RAMOS


The purpose of this paper is to show what work is done, which refactoring tools exist for dynamic languages and to purpose a solution/architecture of a refactoring tool for dynamic languages focused on people that are learning how to program. %change this.


The idea is to create restructuring tool for DrRacket, DrRacket is an integrated development environment (IDE), that was formerly known as DrScheme. It is a simple IDE that was initially build for Racket programming language and it is aimed at inexperienced programmers. ({\bf Fig.~\ref{fig:DrRacketGui}}).
It was designed as a pedagogic environment \cite{drscheme_pegadogy} and it was used in many introductory programming courses in schools around the world. In addition to that DrRacket supports development and extension of other programming languages \cite{tobin2011languages} and recently it have an implementation of python. \cite{ramos2014implementation}


Racket \footnote{http://racket-lang.org/} programming language is a dialect of lisp and a descendant of Scheme and support objects, types and laziness evaluation,
whereas Python is a very high-level programming language that supports the imperative, functional and object-oriented programming paradigms and is very popular in many areas.




%DrRacket Image
\begin{figure}[htbp]
	\centering
	\includegraphics[width=0.95\textwidth]{img/DrRacketGui.png}
	\caption{DrRacket Graphical user interface}
	\label{fig:DrRacketGui}
\end{figure}

%The Section 2 addresses the objectives for this thesis work. Section 3 explore related work in refactoring and restructuring programs, some implemented restructuring tools and some implementations of language independent refactoring tools. Section 4 describes the architecture of the proposed solution. Section 5 explains how the tool will be evaluated and we conclude on section 6.



