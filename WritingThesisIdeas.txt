Refactoring Tool work flow: (add a brief explanation of what does )
The tool uses two pieces of information, def-use-relations and the AST.
It gets the def-use-relations directly from DrRacket, which is visually
represented in a form of Arrows, and are used in refactorings such as Extract-
Method, Add-Prefix, Organize-Imports, etc.

The AST is aquired after using the check-syntax button. It was intended to be
aquired automatically, because DrRacket has an online check syntax, but it was
not possible. After that it cleans the AST removing information that is not
necessary, at least for now, for the refactorings. When the AST is cleaned it
passes the exact part of the AST that was selected. And tries to match rules,
using syntax-parse against that syntax.

Syntax-Parse Utility
Racket gives a function that parses syntax. The Syntax-Parse provided by Racket
is rather useful. because besides having a wide range of auxiliary functions that
helps matching the syntax it also has backtracking. With Backtracking it is
possible to have several rules to be match in the same syntax parser which
helps to create more sophisticated rules.

Online comp Vs Check Syntax button
Online-comp is the racket's online check syntax. Besides being online we do not
know what calls the online syntax expander. Because of that we can not find a
way of storing the AST information that we need to do the refactoring operations.
Not knowing what calls the online syntax expander makes it impossible to store
the information because the instance that receives the AST information is not
accessible, it dissapears.
Having an instance of gui.rkt in
online-comp.rkt / code-walker.rkt does not work either because we can not have 2
instances of the same thing running at the same time.
Therefore there are three posible solutions:

Write to a file
Find out what is calling/starting the handler and get the results from there
 => Use Check Syntax Button
The last one was chosen because the others failed, either because we wasn't able
 to store syntax objects in a file (in a "small" number of time) or because we
 could not find what is calling that (in a "small" number of time).

The solution choosed can be improved by working *automatically*.
To do that we Have two options:
 Use the Online check syntax
 Automate the "call" to the check syntax button.
 Possibilly the automate the call to the check syntax button will be choosen.
 This simplifies the process, however it increases the time that the user has to
 wait, and can make it unusable.

Expanded Program Vs Not expanded Program
#Talk about difficulty, durability, Python (other languages)

[Only in the expanded form] (and) is treated like an if which is bad and give problems
The rest tends to work.
Testando:
(if (= (+ 1 2) 1) #f #t) to (not (= (+ 1 2) 1))

#add an example of both to compare
#difficulty
Racket uses s-expressions to represent the program, basically it represents the
abstract syntax tree (AST) of the program.
Racket has two "trees" the fully expanded program, that has all the macros
expanded and the non expanded program, that is more like the code the user programed.
The fully expanded program loses some information about the program, for example
And. Or, When, Unless are transformed into if forms.
It also adds racket internal representation of the program into the AST.
All these combine make it harder to create refactoring operations to the program,
because it loses information and because it adds unnecessary syntax to the program.
It is necessary to take into consideration that the internal representation of
the program may change in the future and that could make the refactoring tool
useless.


#Sub Cap Code with Macros The Problem
However, if the program contains macros using the non expanded program may
result in semantic incorrect refactoring operations. This is not considered a
problem because this refactoring tool is aimed at unexperienced programmers (that
had one semester of programming classes) and those type of programmers do not use
macros. If we inteneded to create a tool for more experienced programmers the non
expanded program is insufficient and the expanded program must be used.

#python
Using the expanded program might simplify the refactoring for other languages,
for example it has a literal that says when the program returns in python, and
racket does not have it. In the expanded form there is syntax that explicitly says
where the program returns.

In the future it is possible to create a tool that uses both program expansions,
making it possible to have macros and the relation with other languages for the
more difficult problems and using the non expanded program for the simple cases.

Semantic problem (E.g. (and (< 1 (foo 2)) (< (foo 2) 3)) )
The refactoring operation that merges two ands into one, can change the semantic
form of the program. because if foo has collateral effects (changing the value of
a variable, printing some stuff, etc) it will only do that once, instead of twice.
changing the semantic of the program.

Pretty Printing (E.g. Cond lets etc)
The racket makes it easy to create syntax using the syntax-parse to transform the
AST into another AST. however the syntax elements (s-expressions) lose some information
about parentisis. For example it is a convention that cond clauses should be
surronded by [] parentisis but the syntax element does not store that information
 among others. One possible solution to this problem is by using a pretty-printer.
 There are several pretty-printers developed for Racket and even the Racket language
 has one incorporated.
 The one already incorporated does not use the [ ] parentisis, however racket
 supports both representations.




Refactoring Let to Defines Usefulness Vs implementation difficulty
let* vs let
There is a sublte difference between this two keywords that influences directly the simplicity of the solution.
the let defines variables independently, while let* can use the value of the variable defined before.
e.g.
There is a global variable a defined with value 10.
in the let we define variable a with 1 and variable b = a + 1
(let ([a 1]
[b (+ a 1)]))
This let, becauses it defines the variables independently the value of b is 11.
However if it was used let* the value of b would be 2.
let* simplifies the creation of defines and removes the necessity of using the keyword local to ensure semantic preservation.

While the keyword local helps semantic preservation, that is not used very often and can make confusion to the programmer.

Therefore only let* would be considered because it is a more directly representation of a function.

named let.
Named let is a let that has a name and can be called, like a function.
It is directly mapped as a function and therefore might be useful to transform to a function.
The same applies from a function to a named let.

Refactoring Define to Let Usefulness Vs Implementation difficulty

Refactoring (if ?x (begin ?y ...) #f) could go either way:
(when ?x ?y ...)
or
(and ?x (begin ?y ...))

This example shows how hard it is to have an semi-automated refactoring tool
that gives suggestions. It could displays both possibilities, but that will
create an precedent meaning that if a refactoring has several possibilities the
tool has to display every one. Or it could only display that there is a
refactoring opportunity. This requires further reflection to choose the best
approach to the problem.

Implemented Refactoring Operations:


Case Study: (find one) FP Project, Architecture Project.

Future work:
Automated refactoring, after finishing a project to make it more beatufiful.
Automatic Sugesting refactoring opportunities.
Add Python
