TODO => find way to get the unexpanded program... How? Is it possible?

Info that indicates that is not possible.
http://docs.racket-lang.org/tools/drracket_eval.html#%28def._%28%28lib._drracket%2Ftool-lib..rkt%29._drracket~3aeval~3aexpand-program%29%29

TODO => clean result of AST.

FIXME (and) is treated like an if which is bad and give problems
coisas sem ser ands e isso em principio funciona.
Testando:
(if (= (+ 1 2) 1) #f #t) to (not (= (+ 1 2) 1))

TODO => create an syntax object and feed it.
FIXME There is a bug in syntax-walker that for programs with 1 line it does not work.


FIXME => bug while expanding files with classes and stuff. Fix this!

21/09/15 Update: we do not know what calls the online sytax expander, and for
now we can not find a way of passing the information back to the gui.rkt from
the online-comp.rkt / code-walker.rkt. This happens because a new instance is
created of the online-comp.rkt / code-walker.rkt which does not "share" the
values of other instances *duhh*. Having an instance of gui.rkt in
online-comp.rkt / code-walker.rkt does not work either because we can not have 2
instances of the same thing running at the same time.

Possible solutions:
Write to a file
Find out what is calling/starting the handler and get the results from there (??)
 => Use Check Syntax Button


 The last one was chosen because the others failed, either because we wasn't able
 to store syntax objects in a file (in a "small" number of time) or because we
 could not find what is calling that (in a "small" number of time).

 We want to put that working *automatically*, we Have two options:
 Fix the problem
 Automate the "call" to the check syntax button

 22/09/15 Update: New bug found !!FIXED!! DO NOT USE SYNTAX AS ARGUMENT

"Ao tentar usar o syntax-parse dentro de uma class da erros.
"pattern variable cannot be used outside of a template in:..."


e.g.: (syntax-parse #'(if (< 1 2) #t #f)
                #:literals(if)
                [(if test-expr then-expr else-expr) #'then-expr])

Dentro de um (define/private ...) crasha com esse erro, e fora nao. Se
defenir uma funcao ao lado (define (aux)
 (syntax-parse #'(if (< 1 2) #t #f)
                #:literals(if)
                [(if test-expr then-expr else-expr) #'then-expr])) e
chamar tambem da' o mesmo erro.

fora da classe rebenta se passar uma variavel, ou seja
se a funcao receber um argumento, se for sem argumentos nao da erro."
